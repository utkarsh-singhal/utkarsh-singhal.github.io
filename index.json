[{"authors":["admin"],"categories":null,"content":"Hi\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Hi","tags":null,"title":"Utkarsh Singhal","type":"authors"},{"authors":null,"categories":null,"content":"What is Dynamic Programming? DP is an optimization technique.\nDynamic Programming (DP) is used to solve an optimization problem by breaking it down into smaller subproblems and solution of problem will depend upon the solution of the subproblem.\nRequirements of Dynamic Programming\n Overlapping Subproblem         Optimal Substructure          Methods to solve Dynamic Programming  Top-down (Memoization)     Bottom-up (Tabulation)      Steps to Solve DP Problems  Find the recurrence relation  Make the recurrence tree Find the overlapping subproblems   Applying DP  Think how to save the subproblem Use either Top-Down or Bottom-up apporach    Patterns of DP Problems   Fibonacci Pattern\n When the current state is dependent on mulitple previous states  dp[x] = dp[i] + dp[i+1] + ... + dp[x-1]   Similar Problems  Count ways to reach the nth stair using step 1, 2 or 3.  dp[i] = dp[i-1] + dp[i-2] + dp[i-3]   Find maximum possible stolen value from houses.  dp[i] = Max(dp[i-2] + gold[i], dp[i-1))   Count of different ways to express N as the sum of 1, 3 and 4.  dp[i] = dp[i-1] + dp[i-2] + dp[i-3]        0/1 Knapsack\n Let say we have n items now for any item we can take two decision  Take the item (1 State) Leave that item (0 State)   Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack   dp[i-1, values] =\u0026gt; Without picking item i dp[i, values - weight[i]] =\u0026gt; Picking item i only once dp[i, values] = Max(dp[i-1, values], cost[i] + dp[i-1, values - weight[i]]   One popular vairant is when we have unbounded Knapsack that is we can add items multiple items   dp[i-1, values] =\u0026gt; Without picking item i dp[i, values - weight[i]] =\u0026gt; Picking item i (We can pick is multiple times) dp[i, values] = Max(dp[i-1, values], cost[i] + dp[i, values - weight[i]]   Similar Problems  Min Cost Climbing Stairs.  dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i]   Minimum Path Sum.  dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + cost[i][j]        String DP\n  ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"128b943100e0124337a65b8e6220f7fc","permalink":"/notes/dp/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/notes/dp/","section":"notes","summary":"All you need to know about DP.","tags":null,"title":"DP","type":"docs"},{"authors":null,"categories":null,"content":"What is HLD? High-level design (HLD) explains the architecture of the system, a complete view of the entire system in components.\nComponents in high-level design may vary depending upon the scale of the product and other non functional requirements but a typical system has the following components:\n   Componenets  Clients DNS Server CDN Load Balancers App Servers Data Storage  Now let try to understand how these compoenets fits in an user journey.\nUser Journey Let's understand the flow by taking an example of the facebook news feed, a user is trying to fetch his / her news feed.\n   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"fd377bd5a64bfef122c010fb203166ad","permalink":"/systemdesign/hld/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/systemdesign/hld/","section":"systemdesign","summary":"High Level Design.","tags":null,"title":"HLD","type":"docs"},{"authors":null,"categories":null,"content":"List in Python Declare list\ndata = [1,2,3,4]  Add value in list\n# Adding value in x data.append(x)  Get at index in list\n data[index]  Get sublist from a to b+1\n dataList = data[a:b+1] // Sub list from [a,b] dataList = data[:b+1] // Sub list from [0, b] dataList = data[b:] // Sub list from [b, len(data)-1]  Length of list\n len(data)  Remove value from list\n data.remove(x) // Remove value x  Remove from any index\n data.pop(index) // Remove value at index  1-D Array with size n\n [0 for i in range(n)]  2-D Array with size m,n\n [[0 for i in range(n)] for j in range(m)]  Iterate over list\n for (index, value) in enumerate(data): print(index, end = \u0026quot; \u0026quot;) print(value, end = \u0026quot; \u0026quot;)  List Comprehensions\n { value for value in iterable } data = ['a', 'b', 'c', 'd'] data_list = [i for i in data if i != 'a'] print(data_list) data = [i * j for i in [20, 40, 60] for j in [2, 4, 6]] print(data)  Sort list\n sort(key, reverse) vs sorted(iterable, key, reverse) sort() makes changes to the original sequence sorted() returns the new list data.sort() sorted_data = sorted(data) Key(optional): A function that would serve as a key or a basis of sort comparison. Reverse(optional): If set True, then the iterable would be sorted in reverse (descending) order, by default it is set as False. def keyFunc(data): return data[1] keyFuncLambda = lambda data: data[1] data = [(1, 'utkarsh'), (3, 'singhal'), (2, 'amit')] data.sort(key = keyFunc) print(data) data.sort(key = keyFunc, reverse = True) print(data) data1 = sorted(data, key = keyFunc, reverse = True) print(data1)  Dictionary in Python Declare dict\n map = {'a': 1, 'b': 2, 'c':3}  Get from dict\n map = {'a': 1, 'b': 2, 'c':3} value = map['a']  Add in dict\n map = {'a': 1, 'b': 2, 'c':3} map['d'] = 4  Dictionary Comprehension\n { key: value for (key, value) in iterable } dict = { x: x**2 for x in [1,2,3,4,5] } print (dict)  Lambda Lambda creation\n\u0026quot;\u0026quot;\u0026quot; function without name is called Anonymous functions, we can create anonymous functions using lambda \u0026quot;\u0026quot;\u0026quot; squareLambda = lambda x: x**2 def square(x): return x**2 y = squareLambda(2) y = square(2) Both does the same thing \u0026quot;\u0026quot;\u0026quot; lambda with filter filter(function , list): function =\u0026gt; True or False list =\u0026gt; to list which we need to filter Function will return the list after applying function to all the elements \u0026quot;\u0026quot;\u0026quot; data = [1,2,3,4] list_data = list(filter(lambda x: (x%2 != 0), data)) \u0026quot;\u0026quot;\u0026quot; lambda with map filter(function , list): function =\u0026gt; return value list =\u0026gt; to list which we need to filter Function will return the list after applying function to all the elements \u0026quot;\u0026quot;\u0026quot; data = [1,2,3,4] list_data = list(map(lambda x: x**2, data))  Stack, Queue and PriorityQueue Queue\nimport queue \u0026quot;\u0026quot;\u0026quot; Methods supported 1) q.get() Remove and return an item from the queue 2) q.put(item) Add item in the queue 3) q.qsize() Size of the queue 4) q.empty() Check if the queue is empty or not 5) q.queue[0] Get the top element from queue Type of queues: 1) FIFO (Queue) q = queue.Queue(maxsize=n) 2) LIFO (Stack) q = queue.LifoQueue(maxsize=n) 3) PriorityQueue q = queue.PriorityQueue(maxsize=n) Format of data in this queue is a tuple in the form: (priority_number, data) By default it is a min heap \u0026quot;\u0026quot;\u0026quot; q = queue.Queue()  ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"6201c81de9c9e6d1e026975b1f39f4c8","permalink":"/notes/pythoncheatsheet/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/notes/pythoncheatsheet/","section":"notes","summary":"List in Python Declare list\ndata = [1,2,3,4]  Add value in list\n# Adding value in x data.append(x)  Get at index in list\n data[index]  Get sublist from a to b+1\n dataList = data[a:b+1] // Sub list from [a,b] dataList = data[:b+1] // Sub list from [0, b] dataList = data[b:] // Sub list from [b, len(data)-1]  Length of list\n len(data)  Remove value from list","tags":null,"title":"Python Cheat Sheet","type":"docs"},{"authors":null,"categories":null,"content":"We often prefer recursion over iteration while solving problems on tree, dfs, bfs and linked list.\nLet see one simple inorder traversal of a tree using recursion.\nvoid inorder(Node root) { // State 1 inorder(root.left); // State 2 System.out.println(root.data); // State 3 inorder(root.right); // State 4 remove }  As every recursion internally used the recursion stack, let see the stack trace of the above code with an example.\nA stack frame will store the information about the state which is done until now.\n   In the above image, we only remove a frame from the stack when all the states of that frame are done.\nWe will keep 4 States current stackframe state represent the next state to be executed\nvoid inorder(Node root) { Stack\u0026lt;StackFrame\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); StackFrame first = new StackFrame(root, \u0026quot;S1\u0026quot;); stack.push(first); while (stack.size() \u0026gt; 0) { StackFrame top = stack.peek(); if (top.state == \u0026quot;S1\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S2\u0026quot;; StackFrame first = new StackFrame(top.root.left, \u0026quot;S1\u0026quot;); stack.push(first); } else if (top.state == \u0026quot;S2\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S3\u0026quot;; print(top.root.data); } else if (top.state == \u0026quot;S3\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S4\u0026quot;; StackFrame first = new StackFrame(top.root.right, \u0026quot;S1\u0026quot;); stack.push(first); } else { // As all the states are done pop the frame from stack Stack.pop(); } } } class StackFrame { Node root; String state; }  In first go this seems a bit lengthy code but using this conversion we can convert any recursion to iteration.\n","date":1577404800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577404800,"objectID":"50a39cbf848c6c39a483f0db8c7a83be","permalink":"/post/recusion_to_iteration/","publishdate":"2019-12-27T00:00:00Z","relpermalink":"/post/recusion_to_iteration/","section":"post","summary":"We often prefer recursion over iteration while solving problems on tree, dfs, bfs and linked list.\nLet see one simple inorder traversal of a tree using recursion.\nvoid inorder(Node root) { // State 1 inorder(root.left); // State 2 System.out.println(root.data); // State 3 inorder(root.right); // State 4 remove }  As every recursion internally used the recursion stack, let see the stack trace of the above code with an example.\nA stack frame will store the information about the state which is done until now.","tags":null,"title":"Recursion to Iteration","type":"post"}]