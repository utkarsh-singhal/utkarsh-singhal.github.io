[{"authors":["admin"],"categories":null,"content":"Hi\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Hi","tags":null,"title":"Utkarsh Singhal","type":"authors"},{"authors":null,"categories":null,"content":"Array ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"ab871df09e2baab20a7b51455f0a44ad","permalink":"/notes/array/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/notes/array/","section":"notes","summary":"Complete study of arrays, with concepts and best examples.","tags":null,"title":"Array","type":"docs"},{"authors":null,"categories":null,"content":"What is Dynamic Programming? DP is an optimization technique.\nDynamic Programming (DP) is used to solve an optimization problem by breaking it down into smaller subproblems and solution of problem will depend upon the solution of the subproblem.\nRequirements of Dynamic Programming\n Overlapping Subproblem         Optimal Substructure          Methods to solve Dynamic Programming  Top-down (Memoization)     Bottom-up (Tabulation)      Steps to Solve DP Problems  Find the recurrence relation  Make the recurrence tree Find the overlapping subproblems   Applying DP  Think how to save the subproblem Use either Top-Down or Bottom-up apporach    Patterns of DP Problems   Fibonacci Pattern\n When the current state is dependent on mulitple previous states  dp[x] = dp[i] + dp[i+1] + ... + dp[x-1]   Similar Problems  Count ways to reach the nth stair using step 1, 2 or 3.  dp[i] = dp[i-1] + dp[i-2] + dp[i-3]   Find maximum possible stolen value from houses.  dp[i] = Max(dp[i-2] + gold[i], dp[i-1))   Count of different ways to express N as the sum of 1, 3 and 4.  dp[i] = dp[i-1] + dp[i-2] + dp[i-3]        0/1 Knapsack\n Let say we have n items now for any item we can take two decision  Take the item (1 State) Leave that item (0 State)   Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack   dp[i-1, values] =\u0026gt; Without picking item i dp[i, values - weight[i]] =\u0026gt; Picking item i only once dp[i, values] = Max(dp[i-1, values], cost[i] + dp[i-1, values - weight[i]]   One popular vairant is when we have unbounded Knapsack that is we can add items multiple items   dp[i-1, values] =\u0026gt; Without picking item i dp[i, values - weight[i]] =\u0026gt; Picking item i (We can pick is multiple times) dp[i, values] = Max(dp[i-1, values], cost[i] + dp[i, values - weight[i]]   Similar Problems  Min Cost Climbing Stairs.  dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i]   Minimum Path Sum.  dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + cost[i][j]        String DP\n  ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"128b943100e0124337a65b8e6220f7fc","permalink":"/notes/dp/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/notes/dp/","section":"notes","summary":"All you need to know about DP.","tags":null,"title":"DP","type":"docs"},{"authors":null,"categories":null,"content":"What is HLD? High-level design (HLD) explains the architecture of the system, a complete view of the entire system in components.\nComponents in high-level design may vary depending upon the scale of the product and other non functional requirements but a typical system has the following components:\n   Componenets  Clients DNS Server CDN Load Balancers App Servers Data Storage  Now let try to understand how these compoenets fits in an user journey.\nUser Journey Let's understand the flow by taking an example of the facebook news feed, a user is trying to fetch his / her news feed.\n   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"fd377bd5a64bfef122c010fb203166ad","permalink":"/systemdesign/hld/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/systemdesign/hld/","section":"systemdesign","summary":"High Level Design.","tags":null,"title":"HLD","type":"docs"},{"authors":null,"categories":null,"content":"LinkedList ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"31354c9b5e9d93e9aa661879f96ad104","permalink":"/notes/linkedlist/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/notes/linkedlist/","section":"notes","summary":"LinkedList made easy.","tags":null,"title":"LinkedList","type":"docs"},{"authors":null,"categories":null,"content":"We often prefer recursion over iteration while solving problems on tree, dfs, bfs and linked list.\nLet see one simple inorder traversal of a tree using recursion.\nvoid inorder(Node root) { // State 1 inorder(root.left); // State 2 System.out.println(root.data); // State 3 inorder(root.right); // State 4 remove }  As every recursion internally used the recursion stack, let see the stack trace of the above code with an example.\nA stack frame will store the information about the state which is done until now.\n   In the above image, we only remove a frame from the stack when all the states of that frame are done.\nWe will keep 4 States current stackframe state represent the next state to be executed\nvoid inorder(Node root) { Stack\u0026lt;StackFrame\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); StackFrame first = new StackFrame(root, \u0026quot;S1\u0026quot;); stack.push(first); while (stack.size() \u0026gt; 0) { StackFrame top = stack.peek(); if (top.state == \u0026quot;S1\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S2\u0026quot;; StackFrame first = new StackFrame(top.root.left, \u0026quot;S1\u0026quot;); stack.push(first); } else if (top.state == \u0026quot;S2\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S3\u0026quot;; print(top.root.data); } else if (top.state == \u0026quot;S3\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S4\u0026quot;; StackFrame first = new StackFrame(top.root.right, \u0026quot;S1\u0026quot;); stack.push(first); } else { // As all the states are done pop the frame from stack Stack.pop(); } } } class StackFrame { Node root; String state; }  In first go this seems a bit lengthy code but using this conversion we can convert any recursion to iteration.\n","date":1577404800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577404800,"objectID":"50a39cbf848c6c39a483f0db8c7a83be","permalink":"/post/recusion_to_iteration/","publishdate":"2019-12-27T00:00:00Z","relpermalink":"/post/recusion_to_iteration/","section":"post","summary":"We often prefer recursion over iteration while solving problems on tree, dfs, bfs and linked list.\nLet see one simple inorder traversal of a tree using recursion.\nvoid inorder(Node root) { // State 1 inorder(root.left); // State 2 System.out.println(root.data); // State 3 inorder(root.right); // State 4 remove }  As every recursion internally used the recursion stack, let see the stack trace of the above code with an example.\nA stack frame will store the information about the state which is done until now.","tags":null,"title":"Recursion to Iteration","type":"post"}]