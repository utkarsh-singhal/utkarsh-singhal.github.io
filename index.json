[{"authors":["admin"],"categories":null,"content":"Hi\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Hi","tags":null,"title":"Utkarsh Singhal","type":"authors"},{"authors":null,"categories":null,"content":"We often perfer recursion over iteration while solving problems on tree, dfs, bfs and linkedlist.\nLet see one simple inorder traversal of tree using recursion.\nvoid inorder(Node root) { // State 1 inorder(root.left); // State 2 System.out.println(root.data); // State 3 inorder(root.right); // State 4 remove }  As every recursion internally used the recursion stack, let see the stack trace of the above code with an example.\nA stack frame will store the information about the state which is done till now.\n   In above image we only remove a frame from stack when all the states of that frame are done.\nWe will keep 4 States current stackframe state represent the next state to be exceuted\nvoid inorder(Node root) { Stack\u0026lt;StackFrame\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); StackFrame first = new StackFrame(root, \u0026quot;S1\u0026quot;); stack.push(first); while (stack.size() \u0026gt; 0) { StackFrame top = stack.peek(); if (top.state == \u0026quot;S1\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S2\u0026quot;; StackFrame first = new StackFrame(top.root.left, \u0026quot;S1\u0026quot;); stack.push(first); } else if (top.state == \u0026quot;S2\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S3\u0026quot;; print(top.root.data); } else if (top.state == \u0026quot;S3\u0026quot;) { // Update the State of top frame Stack.peek().state = \u0026quot;S4\u0026quot;; StackFrame first = new StackFrame(top.root.right, \u0026quot;S1\u0026quot;); stack.push(first); } else { // As all the states are done pop the frame from stack Stack.pop(); } } } class StackFrame { Node root; String state; }  In first go this seems a bit lengthy code but using this conversion we can convert any recusion to iteration.\n","date":1577404800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577404800,"objectID":"50a39cbf848c6c39a483f0db8c7a83be","permalink":"/post/recusion_to_iteration/","publishdate":"2019-12-27T00:00:00Z","relpermalink":"/post/recusion_to_iteration/","section":"post","summary":"We often perfer recursion over iteration while solving problems on tree, dfs, bfs and linkedlist.\nLet see one simple inorder traversal of tree using recursion.\nvoid inorder(Node root) { // State 1 inorder(root.left); // State 2 System.out.println(root.data); // State 3 inorder(root.right); // State 4 remove }  As every recursion internally used the recursion stack, let see the stack trace of the above code with an example.\nA stack frame will store the information about the state which is done till now.","tags":null,"title":"Recursion to Iteration","type":"post"}]